<?LassoScript define_type:'revolver',-prototype,-priority='replace';	local(		'id'				= null,		'global'			= '_revolver_instances',		'event'			= thread_event,		'created'		= null,		'threads'		= array,		'completed' 	= integer,		'timeout'		= 5000,				'basePath'		= string,		'username'		= string,		'password'		= string,	);		define_tag:'onCreate';		//	Set internals		self->id = lasso_uniqueid;		self->created = date;				//	Insert self into global - for future monitoring		self->global->insert(self->id = @self);		//	Set environmentals		local('timeout') 		? self->'timeout' 	= local('timeout');		local('basePath') 	? self->'basePath' 	= local('basePath');		local('username') 	? self->'username' = local('username');		local('password') 	? self->'password' = local('password');	/define_tag;	define_tag:'onConvert';		return:self->threads->join('<br/>');	/define_tag;	define_tag:'global';		//	Ensure global exists		!	global_defined(self->'global')		?	global(self->'global') = array;		return:@global(self->'global');	/define_tag;		define_tag:'threads';		//	Returns reference to internal threads		return:@self->'threads';	/define_tag;		define_tag:'signal';		//	Count completed threads and signal once complete		self->'completed' +=1;				self->'completed' == self->threads->size 		? 	self->event->signalAll;	/define_tag;		define_tag:'wait',-optional='milliseconds';		//	Light weight pause		sleep(1);		self->isComplete ? return(true);		return(self->'event'->wait(integer(local('milliseconds'))));	/define_tag;		define_tag:'load',		-optional = 'task';				//	Loads a task to be executed		self->threads->insert(			@self->thread(				-id 			= @local('id'),				-task 		= @local('task'),				-name 		= @local('name'),				-owner 		= @local('owner'),				-params 	= @local('params'),				-timeout 	= @local('timeout'),				-username = self->username,				-password 	= self->password,				-basePath 	= (local('basePath') ? local('basePath') | self->basePath),				-revolver 	= @self 			)		);	/define_tag;		define_tag:'abort';		//	Abort all running threads		iterate:self->threads,local('thread');			#thread->id != thread_id ? #thread->abort;		/iterate;	/define_tag;	define_tag:'reload';				//	Resets threads to be re-run		iterate:self->threads,local('thread');			#thread->reset;		/iterate;				//	Reset completed count		self->'completed' = integer;				// Mini breather		sleep:1;	/define_tag;	define_tag:'fire';				//	Reload automatically		self->reload;				//	Set internal thread logic		local(			'_async' 			=  local_defined('async') && string(local('async')) != 'false' ,			'_asyncThreads' =  local_defined('asyncThreads') && local('asyncThreads') != 'false',			'_queueThreads'	=  local_defined('queueThreads') && local('queueThreads') != 'false',		);					if:#_async;			//	Relaunch self as async thread			self->launchAsync(				-revolver 			= @self,				-asyncThreads 	= #_queueThreads, 				-queueThreads 	= #_asyncThreads,			);		else;						//	Thread event for sequential / queued threads			//	Currently unsused as event->signals Clash			local('event') = thread_event;			loop: self->threads->size;							//	Grab thread				local('thread') = @self->threads->get(loop_count);								//	Launch thread				!	#_asyncThreads 				?	#thread->run(-event=@#event) 				|	self->launchAsyncThread(						-thread 		= @#thread,						-event 		= @#event ,					);								if:#_queueThreads;					//	Unfortunatly Lasso confuses thread signals with one and another					//	So here we have to use an ineffecient while loop... :(					//	Solutions welcome...					while:!#thread->'completed';						sleep:5;					/while;				else;					// Breathe					sleep(5);				/if;				//	Wait if should queue - broken until event->signal bug fixed					// #_queueThreads ? @#event->wait(self->timeout);								//	Detach local for next thread				#thread->detachReference;			/loop;		/if;			/define_tag;	define_tag:'isComplete',-atomic;		//	Ask each thread if !complete		iterate:self->threads,local('thread');			!#thread->isComplete ? return: false;		/iterate;		return:true;	/define_tag;	define_tag:'isRunning',-atomic;		//	Ask each thread if isRunning		iterate:self->threads,local('thread');			#thread->isRunning ? return: true;		/iterate;		return:false;	/define_tag;		define_tag:'launchAsync',		//	Relaunch entire Revolver asAsync		-required = 'revolver',		-async;				@#revolver->fire(				-asyncThreads 	= local('queueThreads'), 				-queueThreads 	= local('asyncThreads'),		);		/define_tag;	define_tag:'launchAsyncThread',		//	Launch each task as an aSync thread		-required 	= 'thread', 	-type = 'thread',		-optional 	= 'event', 		-type = 'event',		-optional  	= 'username',-type = 'string',		-optional  	= 'password',	-type = 'string',		-async;				inline: -username=local('username'),-password=local('password');		namespace_using:namespace_page;			!	lasso_tagExists('_thread_basePath')				?	define_constant:'_thread_basePath',#thread->basePath;			define_type:'include';				local('file') = string;				define_tag:'onCreate',-optional='file',-type='string';					self->'file' = string(local('file'));				/define_tag;								define_tag:'onConvert';					'Return: inline->converted';				/define_tag;					define_tag:'filepath';					self->file->beginsWith('/') && _thread_basePath->endsWith('/')					?	return:_thread_basePath + self->file->removeLeading('/')&					|	return:_thread_basePath + self->file;				/define_tag;					define_tag:'onDestroy',-autoOutput;					{							!	file_exists(params)						?	fail(-9984,'The file 'params' was not found (L-Revolver intercepted include)');							return:process(file_read(params));					}->eval(-params=self->filePath);				/define_tag;			/define_type;			define_type:'library';				local('file') = string;				define_tag:'onCreate',-optional='file',-type='string';					self->'file' = string(local('file'));				/define_tag;								define_tag:'onConvert';					'Return: library->converted';				/define_tag;					define_tag:'filepath';					self->file->beginsWith('/') && _thread_basePath->endsWith('/')					?	return:_thread_basePath + self->file->removeLeading('/')&					|	return:_thread_basePath + self->file;				/define_tag;					define_tag:'onDestroy',-autoOutput;					{							!	file_exists(params)						?	fail(-9984,'The file 'params' was not found (L-Revolver intercepted library)');							return:process(file_read(params));					}->eval(-params=self->filePath);				/define_tag;			/define_type;									define_tag:'log',-container;				//	Disable file logging - this will added eventually			/define_tag;						/namespace_using;			@#thread->run(-event=@local('event'));		/inline;			/define_tag;//============================================================================
//
//		->	Internal > Thread Class
//
//............................................................................	define_type:'thread',-prototype;		local(			'id' 				= 0,			'name'			= string,			'task' 			= null,			'owner'			= null,			'revolver'		= null,			'params'		= array,			'objects' 		= map,					'html'				= string,						'username'		= string,			'password'		= string,			'basePath'		= string,						'completed'	= false,			'startTime'		= null,			'endTime'		= null,			'timeout'		= 30,			'info'				= null,			'result'			= string,			'variables'		= array,			'error_code'	= 0, 			'error_msg'	= string, 		);				define_tag:'onCreate',			-required = 'task',			-required = 'revolver';						//	Core task to run (tag,type,string)			self->'task' 	= @local('task');						//	Set internal revolver reference				self->'revolver'= @local('revolver');			//	Params to be passed to task						local('params')->size ? self->'params'= @local('params');			//	Set owner of task						local('owner')->type != 'null' ? self->'owner'= @local('owner');			//	Optional parameters			local('id')				? self->'id'		= local('id');			local('name')			? self->'name'	= local('name');			local('html')			? self->'html'		= local('html');			local('timeout')		? self->'timeout'= local('timeout');			local('basePath')	? self->'basePath'= local('basePath');			local('username')	? self->'username'= local('username');			local('password')	? self->'password'= local('password');		/define_tag;				define_tag:'onConvert';			if:self->html;				return:process(self->html);			else;				return: self->info->join('<br/>');			/if;		/define_tag;				define_tag:'setInfo';			return:self->'info' = self->info;		/define_tag;								define_tag:'info';			self->'info'->isA('map')			?	return:self->'info' 			|	return:map(								'id' 				= self->id,								'name' 			= self->name,								'basePath' 		= self->basePath,																'startTime' 		= self->startTime,								'endTime' 			= self->endTime,								'processTime'		= self->processTime,																'result' 			= self->result,								'variables' 		= self->variables,								'error_code' 	= self->error_code,								'error_msg' 	= self->error_msg,																'debug'			= self->getDebug 							);		/define_tag;				define_tag:'id';			return:self->'id';		/define_tag;		define_tag:'status';			if:self->isComplete;				return: 'Completed';			else:self->isRunning;				return: 'Running';			else;				return: 'Waiting';			/if;		/define_tag;		define_tag:'processTime';			self->startTime			?	return: decimal(math_max(0,(self->endTime ? self->endTime | date_mSec) - self->startTime)*0.001)->setFormat(-precision=3)& 			|	return: 0.000;		/define_tag;				define_tag:'isComplete';			return:self->'completed' == true || self->'error_code' != 0;		/define_tag;		define_tag:'isRunning';			return: !self->isComplete && self->startTime;		/define_tag;		define_tag:'variables';			return:variables->keys;		/define_tag;				define_tag:'run',-optional='event';			protect;				inline:					-username = self->username,					-password 	 = self->password;							self->'id' = thread_getCurrentID;						self->'startTime' = date_mSec;								lasso_executionTimeLimit(self->timeout);				handle;								self->'completed'	= true;					self->'endTime' 	= date_mSec;					self->'error_code' 	= error_code;					self->'error_msg' 	= error_msg;					self->setInfo;					self->revolver->signal;					//local('event')->isA('event') ? #event->signal;				/handle;								select:self->'task'->type;					case:'string';						self->result = process(self->'task');					case:'tag';						self->result = self->'task'->run(-params=@self->params,-owner=@self->owner);					case;						self->result = self->'task'->invoke(@self->params);				/select;				/inline;						/protect;					/define_tag;				define_tag:'getDebug';			//	Returns existing L-Debug stack			protect;				return(debug);			/protect; 		/define_tag;		define_tag:'debug';			return(self->info->find('debug'));		/define_tag;		define_tag:'abort';			self->id ?	thread_abort(self->id);		/define_tag;			define_tag:'reset';			self->'id' 				= null;			self->'info' 			= null;			self->'completed'	= false;			self->'startTime'	= null;			self->'endTime'		= null;			self->'info'			= null;			self->'result'			= string;			self->'variables'	= array;			self->'error_code'	= 0;			self->'error_msg'	= string; 		/define_tag;		/define_type;/define_type;		?>